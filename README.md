# Lab-2
#### № группы: `ПМ-2501`

#### Выполнила: `Рогулина Екатерина Павловна`

#### Вариант: `19`

### Cодержание:
- [Задание №1](#1-задание)
- [Задание №2](#2-задание)
- [Задание №3](#3-задание)
- [Задание №4](#4-задание)

### 1 задание
#### Постановка задачи
При вводе a0 (нулевого элемента последовательности) и  n (количества элементов последовательности) на выходе получаем значение этих n элементов последовательности. Необходимо определить закономерность последовательности и запрограммировать её.
#### Наблюдение при запуске готовой программы
1) Значение элемента не имеет значения (т.е. важен только порядковый номер элемента);
2) Элементы на чет местах имеют свою закономерность, а элементы на нечет местах свою, они независимы друг от друга;
3) Элементы с нечет индексами образуют последовательность двойки возведенную в степень, каждый раз увеличенную на 2; элементы с четными индексами (i) представляют из себя элемент с индексом (i-2) умноженным на переменную, возрастающую каждый раз на 14+d, где переменная с также возрастает с каждым разом на 8;
4) Элемент с индексом 0 всегда равен единице.
#### Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int a0 = in.nextInt();
        int n = in.nextInt();
        double[] a = new double[n];
        for (int i = 0, b=2, c=6, d=0; i < n; i++) {
            if (i%2!=0) {
                a[i]=Math.pow(2, b);
                b+=2; }
            else {
                if (i==0)
                    a[i]=1;
                else {
                    a[i]=a[i-2]*c;
                    c+=14+d;
                    d+=8;}}}
        for (int i = 0; i<n; i++)
            out.printf("%.0f%n", a[i]);
        out.println();
    }
}
```
#### Анализ правильности решения
##### Ввод
1) a0=1
2) n=7
##### Вывод
1,
4,
6,
16,
120,
64,
5040
### 2 задание
#### Постановка задачи
В кассе парка развлечений выдаются специальные жетоны. У каждого – уникальный числовой код. При формировании комплекта из n жетонов в кассе автоматически рассчитывается контрольный код для проверки целостности набора. Так как по условию способ формирования контрольного кода можно придумать самим, будем считать что контрольный код - сумма уникальных кодов всех жетонов. У кассы есть правило: порядок жетонов не имеет значения. Но если один и тот же жетон по ошибке положить дважды, то он считается фальшивым и уничтожается, не влияя на результат. Позднее при проверке в мешке нашли только (n - 1) жетон. Значит в наборе было два жетона с одинаковым уникальным кодом, один из которых был уничтожен. Для того чтобы определить код уничтоженного жетона нужно вычесть из контрольного кода сумму уникальных кодов остальных жетонов.
#### Входные данные
  1) число n
  2) (n - 1) целых чисел – коды найденных жетонов
  3) одно целое число – контрольный код кассы (нужно учитывать, что контрольный код должен быть больше суммы (n-1) уникальных кодов найденных жетонов, при этом отличаться на число, равное одному из известных нам кодов)
#### Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int n = in.nextInt();
        int s = 0;
        int[] a = new int[n-1];
        for (int i = 0; i < n-1; i++) {
            a[i] = in.nextInt();
            s+=a[i]; }
        int k = in.nextInt();
        out.print(k-s);
    }
}
```
#### Анализ правильности решения
##### Ввод:
1) 6
2) 11 12 13 14 15
3) 79
##### Вывод:
14
### 3 задание
#### Постановка задачи
Задано начальное число X0. Нужно угадать некоторое задуманное число X. На каждом шаге подается ответ: 1, если задуманное число больше текущего; -1, если меньше; и 0, если число угадано. Движение организовано так: если несколько одинаковых ответов идут подряд, то шаг каждый раз удваивается и прибавляется или вычитается от текущего числа; если же направление меняется, то шаг делится пополам (с округлением вверх, но всегда не меньше 1) и затем движение продолжается уже в другую сторону. Нужно определить, какое загаданное число соответствует такой последовательности ответов и сколько шагов потребовалось для его достижения.
#### Входные данные
    1) целое число X0
    2) последовательность ответов из {1, -1, 0}, где 0 означает окончание игры  
#### Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int x0 = in.nextInt();
        int s = 0;
        int c = 1;
        int b = 0;
        int a = in.nextInt();
        while (a!=0) {
            if (a==b) {
                c=c*2;
                x0+=c; }
            if (a!=b && b!=0) {
                c=-c/2;
                x0+=c; }
            if (b==0)
                x0+=a;
            b=a;
            a = in.nextInt();
            s+=1;}
        out.println(x0);
        out.print(s);
    }
}
```
#### Анализ правильности решения
##### Ввод:
1) 15
2) 1 1 1 1 -1 -1 
##### Вывод:
18
### 4 задание
#### Постановка задачи
Дан массив из n символов. Подсчитать и вывести количество каждого символа без учета регистра, а также вывести наиболее часто встречающийся символ.
#### Входные данные
    1) число n
    2) n символов
#### Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        int n = in.nextInt();
        char[] a = new char[n];
        char[] b = new char[n];
        int[] c = new int[256];
        for (int i = 0; i < n; i++) {
            a[i] = in.next().charAt(0);
            b[i] = Character.toLowerCase(a[i]);
            c[b[i]]++;
        }
        char x = ' ';
        int max = 0;
        for (int i = 0; i < c.length; i++) {
            if (c[i] > max) {
                max = c[i];
                x = (char) i;
            }
        }
        for (int i = 0; i < c.length; i++) {
            if (c[i] > 0) {
                char d = (char) i;
                System.out.println(d+ ": " + c[i] + " раз");}}
        out.print("Наиболее часто встречающийся: " + x);
    }
}
```
#### Анализ правильности решения
##### Ввод:
1) 6
2) d D q w e r
##### Вывод:
d: 2
q: 1
w: 1
e: 1
r: 1
Наиболее часто встречающийся: d
